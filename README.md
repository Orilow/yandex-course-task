# Проект второго семестра

Проект второго семестра – сервис интерактивных приключений **Telltail Games**.

**Приключение** – это набор **сцен**, по которым пользователь перемещается, выбирая как **действовать** на каждой из них, в итоге приходя либо к печальному концу :skull:, либо к заветной победе :tada:, по пути зарабатывая **достижения**.

Примеры таких приключений – [бумажные книги приключений](https://ru.wikipedia.org/wiki/Choose_Your_Own_Adventure) или [игры студии Telltale Games](https://telltale.com/series/)

<img src="https://yastatic.net/s3/locdoc/daas-static/telltail/demo.png" width=800>

Вы будете разрабатывать похожую механику, но уже в рамках web-сервиса.   
Вот что должно получиться уже после первого домашнего задания:

<img src="https://yastatic.net/s3/locdoc/daas-static/telltail/demo7.gif">

[Ссылка на демонстрацию](https://yastatic.net/s3/locdoc/daas-static/telltail/demo.gif), если не открывается картинка

Мы разбили проект на несколько домашних заданий:

# Первое задание

В первом задании необходимо создать основу для сервиса с самой базовой механикой и разместить его в облаке.

- [Макет](#%D0%BC%D0%B0%D0%BA%D0%B5%D1%82)
- [Требования и ограничения](#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)
  - [Требования к данным](#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC)
  - [Требования к приложению](#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8E)
  - [Ограничения по технологиям](#%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F%D0%BC)
  - [Требования к инфраструктуре](#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D0%B8%D0%BD%D1%84%D1%80%D0%B0%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B5)
  - [Дополнительные ограничения](#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)

## Макет

Для того, чтобы вам было проще разобраться с механикой приключений, мы подготовили [интерактивный макет](https://www.figma.com/proto/2kQPxLC0N6CWbPMFRr2RFM/Telltail-Games-2?node-id=2350%3A101&scaling=min-zoom).

<img src="https://yastatic.net/s3/locdoc/daas-static/telltail/demo7.gif">

## Требования и ограничения

### Требования к данным

Приключения необходимо хранить в **PostgreSQL**. Для этого, в качестве облачной базы, данных мы рекомендуем использовать [ElephantSQL](https://www.elephantsql.com).

Для первого задания вам понадобятся следующие сущности:
* Приключения
* Сцены
* Действия
* Хэштеги
* Ачивки

Их необходимо разместить в *разных* таблицах и  
самостоятельно организовать связи между ними.

### Требования к приложению

* Интерфейс должен [соответствовать макету](https://www.figma.com/file/2kQPxLC0N6CWbPMFRr2RFM/Telltail-Games-2?node-id=0%3A1)
* В макете используются шрифты [Roboto](https://fonts.google.com/specimen/Roboto) и [Gabriela](https://fonts.google.com/specimen/Gabriela?selection.family=Gabriela)
* **Главная страница** – это список всех приключений
  * Логотип – всегда ссылка на главную страницу
  * Название и картинка – ссылка на **начальную сцену** приключения
  * Если у приключения нет **начальной сцены** – его не должно быть в списке
  * Хештег – ссылка на страницу хештега. Их может несколько, а может быть и ноль.
  * Описание может быть, а может и нет
  * Картинка может быть, а может и нет, в этом случае выводится картинка по-умолчанию
* **Страница хештега** – список приключений, у которых он есть
  * У хештега должен быть название на русском языке, не включающее `#`
  * Но в адресе должно быть англоязычное сооветствие. Например, для хештега «#магия» в адресе должно быть «magic»
* **Страница сцены**
  * Сцена состоит из картинки, описания сцены и действий под ней
  * Картинка может любого размера и пропорций, но её необходимо вписывать в заданные макетом
  * Описание сцены может располагаться в одном из углов картинки, задаётся свойством сцены
  * Сцена может не содержать картинку, тогда просто выводится описание в левом верхнем углу
  * Сцена может не содержать описание
  * Сцена может содержать *любое* количество действий. Их необходимо выводить по центру.
    * Действие – ссылка на следующую сцену
    * Действие может вести и на одну из уже пройденных сцен – пользователь может ходить по кругу.
    * Если действий у сцены нет – это **финальная сцена**. Необходимо вывести кнопку «Начать заново» – ведёт к **начальной сцене**.
  * *Любая* сцена может содержать любое количество **ачивок**. Их необходимо выводить между картинкой и действиям, друг под другом, по две в ряд. Состоят из текста и квадратного изображения, которое необходимо вписать в круг.
* На несуществующие страницы необходимо отвечать с кодом 404
* В случае ошибки необходимо отвечать с кодом 500

### Ограничения по технологиям

Первая версия приложения должна быть построена на следующих технологиях:

- [TypeScript](https://www.typescriptlang.org)
- [Node.js](https://nodejs.org)
- [Express.js](https://expressjs.com/ru/)
- [PostgreSQL](https://www.postgresql.org)
- [Sequelize](http://docs.sequelizejs.com)
- [Handlebars for Express.js](https://github.com/pillarjs/hbs)

А в остальном на ваше усмотрение.

### Требования к инфраструктуре

* Сервис необходимо разместить в облаке [Heroku](https://heroku.com).
    
    Адрес, по которому должен быть доступен сервис:  
    `https://<github_login>-task-2019.herokuapp.com`  
    
    Например, https://VasiliiKuznecov-task-2019.herokuapp.com
    
    Для размещения использовать **Docker**
* Статичное содержимое необходимо разместить в любом из CDN, например, [Surge](https://surge.sh/help/getting-started-with-surge)
* Необходимо выбрать правила для проверки вашего CSS и TypeScript кода и следовать им

### Дополнительные ограничения

* Все картинки необходимо хранить в виде *общедоступных ссылок* на них
* Задачу необходимо решить **без использования клиентского JavaScript**. Все – кнопки это просто ссылки.


# Второе задание

Во втором задании необходимо оживить главную страницу и страницу хештега,  
используя JavaScript, DOM и другие API браузера в чистом виде.

## Новые требования к приложению

* Список приключений при первой загрузке страницы должен содержать не более **5** приключений
  * Как только пользователь прокрутил страницу до последнего из пяти – появился заголовок, необходимо **асинхронно** загрузить следующую пачку из 5. И так до тех пор, пока приключения не закончатся (в последней пачке может быть менее 5). Для отслеживания момента появления элемента на экране пользователя, вам может пригодиться [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).
  * Если экран пользователя настолько большой, что влезли все первые 5 приключений – можно загружать следующую пачку асинхронно сразу после загрузки страницы
  * На клиент должны приходить только данные, например в JSON формате, а не готовый HTML
  * Используя DOM API необходимо отобразить полученные с сервера данные. Отдавайте предпочтение таким методам как *createElement*, *appendChild* и *classList*, а не вставкам строк большого размера через *innerHTML*.
  * В случае ошибки необходимо показать сообщение «Не удалось загрузить приключения» в любой удобной для пользователя форме
* По клику на хештег, связанные с ним приключения необходимо загрузить **асинхронно** и также отобразить полученные данные используя DOM API
  * При этом адрес страницы должен измениться, а предыдущая страница должна сохраниться в истории просмотра пользователя. Здесь вам может пригодиться [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).

## Ограничения по технологиям

Мы оставляем тот же набор технологии, что и для первого задания, но для клиентской логики на стороне браузера теперь необходимо использовать **чистый JavaScript**, DOM и другие API браузера. 

**Без React, Redux, jQuery и других сторонних библиотек**. За одиним исключением – для организации взаимодействия между сервером и браузером можете выбрать любой подход и стороннюю библиотеку.

Для клиентского JavaScript кода можно использовать **самый современный стандарт** (даже async и await). Проверять будем в последней версии [Яндекс.Браузера](https://browser.yandex.ru/).


# Третье задание

Вместо handlebars и чистого JavaScript для организации всего клиентского кода теперь необходимо использовать **React**. При этом можно выбрать любые сопутствующие библиотеки: Redux, React Router, Redux Saga – на ваше усмотрение.
